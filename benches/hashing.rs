use criterion::{criterion_group, criterion_main, Criterion};
use rug::Integer;
use rust_ev_crypto_primitives::{
    ByteArray, DecodeTrait, HashableMessage, Hexa, RecursiveHashTrait,
};

pub fn recursive_hash_bench(c: &mut Criterion) {
    let mut nl: Vec<HashableMessage> = vec![];
    let bu1 = Integer::from_hexa_string("0x4").unwrap();
    nl.push(HashableMessage::from(&bu1));
    let bu2 = Integer::from_hexa_string(
            "0x3896D05A527747E840CEB0A10454DE39955529297AC4CB21010E9287A21F826FA7221215E1C7EE8362223DF51215A7F4CD14F158980154EE0794B599639A6FBC171A97F376A4DD95945C476F0DC6836FCEA68C9B28F901CE7F30DC03F406947E6245BF741650F5164BFC24F4B23948A5D6642C36D61016E63E943DB9717335EEB04373BFAE10BB4FB20EA9FD1BE48CA9A02B8E8C6639AD8E43D714ED16D4764D258E9A70BABD5497C09E148052C1C6A965F18F71F7B03385178B4991AA790611FA3B98E9C2F1EE1E0369F496A1D6928D718650513439D01898AAB87BC968F76D9DB8089809142A0C79A84C689D02314CEDE64F4C9615B79D49D2BE641BE8D4AB"
        ).unwrap();
    nl.push(HashableMessage::from(&bu2));
    let mut l: Vec<HashableMessage> = vec![];
    l.push(HashableMessage::from("common reference string"));
    let bu3 = Integer::from_hexa_string(
            "0xB7E151628AED2A6ABF7158809CF4F3C762E7160F38B4DA56A784D9045190CFEF324E7738926CFBE5F4BF8D8D8C31D763DA06C80ABB1185EB4F7C7B5757F5958490CFD47D7C19BB42158D9554F7B46BCED55C4D79FD5F24D6613C31C3839A2DDF8A9A276BCFBFA1C877C56284DAB79CD4C2B3293D20E9E5EAF02AC60ACC93ED874422A52ECB238FEEE5AB6ADD835FD1A0753D0A8F78E537D2B95BB79D8DCAEC642C1E9F23B829B5C2780BF38737DF8BB300D01334A0D0BD8645CBFA73A6160FFE393C48CBBBCA060F0FF8EC6D31BEB5CCEED7F2F0BB088017163BC60DF45A0ECB1BCD289B06CBBFEA21AD08E1847F3F7378D56CED94640D6EF0D3D37BE69D0063"
        ).unwrap();
    l.push(HashableMessage::from(&bu3));
    let bu4 = Integer::from_hexa_string(
            "0x5BF0A8B1457695355FB8AC404E7A79E3B1738B079C5A6D2B53C26C8228C867F799273B9C49367DF2FA5FC6C6C618EBB1ED0364055D88C2F5A7BE3DABABFACAC24867EA3EBE0CDDA10AC6CAAA7BDA35E76AAE26BCFEAF926B309E18E1C1CD16EFC54D13B5E7DFD0E43BE2B1426D5BCE6A6159949E9074F2F5781563056649F6C3A21152976591C7F772D5B56EC1AFE8D03A9E8547BC729BE95CADDBCEC6E57632160F4F91DC14DAE13C05F9C39BEFC5D98068099A50685EC322E5FD39D30B07FF1C9E2465DDE5030787FC763698DF5AE6776BF9785D84400B8B1DE306FA2D07658DE6944D8365DFF510D68470C23F9FB9BC6AB676CA3206B77869E9BDF34E8031"
        ).unwrap();
    l.push(HashableMessage::from(&bu4));
    let ba = ByteArray::base64_decode("YcOpYm5zaXRwcSBi").unwrap();
    l.push(HashableMessage::from(&ba));
    l.push(HashableMessage::from(nl));
    let value = HashableMessage::from(&l);
    c.bench_function("recursive_hash", |b| {
        b.iter(|| value.recursive_hash().unwrap())
    });
}

pub fn recursive_hash_to_zq_bench(c: &mut Criterion) {
    let q = Integer::from_hexa_string(
            "0x5BF0A8B1457695355FB8AC404E7A79E3B1738B079C5A6D2B53C26C8228C867F799273B9C49367DF2FA5FC6C6C618EBB1ED0364055D88C2F5A7BE3DABABFACAC24867EA3EBE0CDDA10AC6CAAA7BDA35E76AAE26BCFEAF926B309E18E1C1CD16EFC54D13B5E7DFD0E43BE2B1426D5BCE6A6159949E9074F2F5781563056649F6C3A21152976591C7F772D5B56EC1AFE8D03A9E8547BC729BE95CADDBCEC6E57632160F4F91DC14DAE13C05F9C39BEFC5D98068099A50685EC322E5FD39D30B07FF1C9E2465DDE5030787FC763698DF5AE6776BF9785D84400B8B1DE306FA2D07658DE6944D8365DFF510D68470C23F9FB9BC6AB676CA3206B77869E9BDF3380470C368DF93ADCD920EF5B23A4D23EFEFDCB31961F5830DB2395DFC26130A2724E1682619277886F289E9FA88A5C5AE9BA6C9E5C43CE3EA97FEB95D0557393BED3DD0DA578A446C741B578A432F361BD5B43B7F3485AB88909C1579A0D7F4A7BBDE783641DC7FAB3AF84BC83A56CD3C3DE2DCDEA5862C9BE9F6F261D3C9CB20CE6B"
        ).unwrap();
    let v = vec![
            HashableMessage::from("test string".to_string()),
            HashableMessage::from(ByteArray::base64_decode("q83vASNFZ4k=").unwrap()),
            HashableMessage::from(
                Integer::from_hexa_string(
                    "0x12956ABFFD9522888502E77884C7DF9D659BF4F93D908E01E04B56693E7A73D75AB513F16F805F70FE3D20404273E4E1611893C682EA1AE50E1C56A83F6ECC1A8580AE96568CD7412B6D70F9B1979CF52CAD3D2DDD9BCF8C3DB027E1E0B316B0B94D753CADC38F179888365382964006CF4EF543FDE8C2A4F138933502A250E98D0B13B871EE046E8A4656D2C5563A910E613D603E3A5DEFC941062530C0B0F02DBA35C1CEE7FF33E62E617B20BAC3499E33BA66BAC64A4D5EB63683089781BA0ECF82557164535ECDC8E26FE104ECF458D81BD25D55FB12B533B940C73D36F903FD4A5993A7535C62B00E2886816BB642F832D98DE8081853979652476331E52EB5FB9BC62081121748896623638FA4F5397FB1B203774F247B4A7A6350A671B2AE37CBCAC931DE417047E38C2218BD8EC4909E7D41B30A5D5E9C9788A7E866FA5FFAB69E0E815BFFB3F244503DE422F962B61C6881FFC3A4D027C4C1C4F285CAD46C6B4F25D2DCA2D81316E9C86623E5C71C56C0BDCC9C9C8E074BC5A3B746"
                ).unwrap()
            )
        ];
    let value = HashableMessage::from(&v);
    c.bench_function("recursive_hash_to_zq", |b| {
        b.iter(|| value.recursive_hash_to_zq(&q).unwrap())
    });
}

criterion_group!(benches, recursive_hash_bench, recursive_hash_to_zq_bench);
criterion_main!(benches);
