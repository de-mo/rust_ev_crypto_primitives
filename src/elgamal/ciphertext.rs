// Copyright Â© 2023 Denis Morel

// This program is free software: you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option) any
// later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
// details.
//
// You should have received a copy of the GNU Lesser General Public License and
// a copy of the GNU General Public License along with this program. If not, see
// <https://www.gnu.org/licenses/>.

//! Implementation of the ciphertext operations

use std::iter::once;

use crate::{ integer::MPInteger, Constants, HashableMessage, Operations };
use super::{ EncryptionParameters, ElgamalError };

#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct Ciphertext {
    pub gamma: MPInteger,
    pub phis: Vec<MPInteger>,
}

impl Ciphertext {
    pub fn from_expanded(gamma: &MPInteger, phis: &[MPInteger]) -> Self {
        Self {
            gamma: gamma.clone(),
            phis: phis.to_vec(),
        }
    }

    pub fn l(&self) -> usize {
        self.phis.len()
    }

    pub fn neutral_for_mod_multiply(l: usize) -> Self {
        Self::from_expanded(MPInteger::one(), vec![MPInteger::one().clone();l].as_slice())
    }

    /// Algorithm 8.5 GetCiphertext
    pub fn get_ciphertext(
        ep: &EncryptionParameters,
        ms: &[MPInteger],
        r: &MPInteger,
        pks: &[MPInteger]
    ) -> Result<Self, ElgamalError> {
        let l = ms.len();
        let k = pks.len();
        let p = ep.p();
        if l == 0 && l > k {
            return Err(ElgamalError::LNotCorrect);
        }
        let gamma = ep.g().mod_exponentiate(r, p);
        let phis: Vec<MPInteger> = ms
            .iter()
            .zip(pks.iter())
            .map(|(m, pk)| pk.mod_exponentiate(r, p).mod_multiply(m, p))
            .collect();
        Ok(Self { gamma, phis })
    }

    /// Algorithm 8.6 GetCiphertextExponentiation
    pub fn get_ciphertext_exponentiation(&self, a: &MPInteger, ep: &EncryptionParameters) -> Self {
        let p = ep.p();
        let gamma = self.gamma.mod_exponentiate(a, p);
        let phis: Vec<MPInteger> = self.phis
            .iter()
            .map(|phi| phi.mod_exponentiate(a, p))
            .collect();
        Self { gamma, phis }
    }

    /// Algorithm 8.8 GetCiphertextProduct
    pub fn get_ciphertext_product(&self, other: &Self, ep: &EncryptionParameters) -> Self {
        let p = ep.p();
        let gamma = self.gamma.mod_multiply(&other.gamma, p);
        let phis: Vec<MPInteger> = self.phis
            .iter()
            .zip(other.phis.iter())
            .map(|(phi_a, phi_b)| phi_a.mod_multiply(phi_b, p))
            .collect();
        Self { gamma, phis }
    }

    /// Algorithm 8.7 GetCiphertextVectorExponentiation
    pub fn get_ciphertext_vector_exponentiation(
        cs: &[Ciphertext],
        a: &[MPInteger],
        ep: &EncryptionParameters
    ) -> Self {
        let ones_cipher = Self::from(vec![MPInteger::one().clone(); cs.len()].as_slice());
        cs.iter()
            .zip(a.iter())
            .map(|(c, a)| c.get_ciphertext_exponentiation(a, ep))
            .fold(ones_cipher, |acc, c| acc.get_ciphertext_product(&c, ep))
    }
}

impl<'a> From<&'a Ciphertext> for HashableMessage<'a> {
    fn from(value: &'a Ciphertext) -> Self {
        HashableMessage::from(
            once(&value.gamma)
                .chain(value.phis.iter())
                .map(HashableMessage::from)
                .collect::<Vec<HashableMessage<'a>>>()
        )
    }
}

impl<'a> From<Ciphertext> for HashableMessage<'a> {
    fn from(value: Ciphertext) -> Self {
        HashableMessage::from(
            once(value.gamma.clone())
                .chain(value.phis)
                .map(HashableMessage::from)
                .collect::<Vec<HashableMessage<'a>>>()
        )
    }
}

impl<'a> From<&'a Vec<Ciphertext>> for HashableMessage<'a> {
    fn from(value: &'a Vec<Ciphertext>) -> Self {
        HashableMessage::from(
            value.iter().map(HashableMessage::from).collect::<Vec<HashableMessage<'a>>>()
        )
    }
}

impl<'a> From<&'a [Ciphertext]> for HashableMessage<'a> {
    fn from(value: &'a [Ciphertext]) -> Self {
        HashableMessage::from(
            value.iter().map(HashableMessage::from).collect::<Vec<HashableMessage<'a>>>()
        )
    }
}

impl<'a> From<Vec<Ciphertext>> for HashableMessage<'a> {
    fn from(value: Vec<Ciphertext>) -> Self {
        HashableMessage::from(
            value
                .iter()
                .map(|e| HashableMessage::from(e.clone()))
                .collect::<Vec<HashableMessage<'a>>>()
        )
    }
}

impl<'a> From<&'a Vec<&'a Ciphertext>> for HashableMessage<'a> {
    fn from(value: &'a Vec<&'a Ciphertext>) -> Self {
        HashableMessage::from(
            value
                .iter()
                .map(|&c| HashableMessage::from(c))
                .collect::<Vec<HashableMessage<'a>>>()
        )
    }
}

impl<'a> From<Vec<&'a Ciphertext>> for HashableMessage<'a> {
    fn from(value: Vec<&'a Ciphertext>) -> Self {
        HashableMessage::from(
            value
                .iter()
                .map(|&c| HashableMessage::from(c))
                .collect::<Vec<HashableMessage<'a>>>()
        )
    }
}

impl From<&[MPInteger]> for Ciphertext {
    fn from(value: &[MPInteger]) -> Self {
        Self { gamma: value[0].clone(), phis: value.iter().skip(1).cloned().collect() }
    }
}

#[cfg(test)]
mod test {
    use crate::Hexa;
    use super::*;

    #[test]
    fn test_get_cyphertext() {
        let p = MPInteger::from_hexa_string(
            "0xB7E151628AED2A6ABF7158809CF4F3C762E7160F38B4DA56A784D9045190CFEF324E7738926CFBE5F4BF8D8D8C31D763DA06C80ABB1185EB4F7C7B5757F5958490CFD47D7C19BB42158D9554F7B46BCED55C4D79FD5F24D6613C31C3839A2DDF8A9A276BCFBFA1C877C56284DAB79CD4C2B3293D20E9E5EAF02AC60ACC93ED874422A52ECB238FEEE5AB6ADD835FD1A0753D0A8F78E537D2B95BB79D8DCAEC642C1E9F23B829B5C2780BF38737DF8BB300D01334A0D0BD8645CBFA73A6160FFE393C48CBBBCA060F0FF8EC6D31BEB5CCEED7F2F0BB088017163BC60DF45A0ECB1BCD289B06CBBFEA21AD08E1847F3F7378D56CED94640D6EF0D3D37BE67008E186D1BF275B9B241DEB64749A47DFDFB96632C3EB061B6472BBF84C26144E49C2D04C324EF10DE513D3F5114B8B5D374D93CB8879C7D52FFD72BA0AAE7277DA7BA1B4AF1488D8E836AF14865E6C37AB6876FE690B571121382AF341AFE94F77BCF06C83B8FF5675F0979074AD9A787BC5B9BD4B0C5937D3EDE4C3A79396419CD7"
        ).unwrap();
        let q = MPInteger::from_hexa_string(
            "0x5BF0A8B1457695355FB8AC404E7A79E3B1738B079C5A6D2B53C26C8228C867F799273B9C49367DF2FA5FC6C6C618EBB1ED0364055D88C2F5A7BE3DABABFACAC24867EA3EBE0CDDA10AC6CAAA7BDA35E76AAE26BCFEAF926B309E18E1C1CD16EFC54D13B5E7DFD0E43BE2B1426D5BCE6A6159949E9074F2F5781563056649F6C3A21152976591C7F772D5B56EC1AFE8D03A9E8547BC729BE95CADDBCEC6E57632160F4F91DC14DAE13C05F9C39BEFC5D98068099A50685EC322E5FD39D30B07FF1C9E2465DDE5030787FC763698DF5AE6776BF9785D84400B8B1DE306FA2D07658DE6944D8365DFF510D68470C23F9FB9BC6AB676CA3206B77869E9BDF3380470C368DF93ADCD920EF5B23A4D23EFEFDCB31961F5830DB2395DFC26130A2724E1682619277886F289E9FA88A5C5AE9BA6C9E5C43CE3EA97FEB95D0557393BED3DD0DA578A446C741B578A432F361BD5B43B7F3485AB88909C1579A0D7F4A7BBDE783641DC7FAB3AF84BC83A56CD3C3DE2DCDEA5862C9BE9F6F261D3C9CB20CE6B"
        ).unwrap();
        let g = MPInteger::from(4u8);
        let ms: Vec<MPInteger> = [
            "0x291508188EC65E90B8293F9AE2C4B2311CFD46725E24725D640ED1111E23279DB9B025BCA21570646D47D3BC00174BD87C78DF132B6C86FD609660038B07ABCD361792AB56B327649DB02F527D36D81E22274587B4F778D8E4C4DFC44C85117A6BB16BC2B6EEDC9B0D89013178310BC8ADC88CA5D136EA88B9E9409AC6C6A798B9787CB52684E9F0E24E851C1F7AC1649FFE40E2D355BD66C11E112BB8B0F2FF080253BB84038A33FBA2AB48F9A4BB66FA30E702991131CDEEF298A0D57A67DCE81CDD9285AAFCEFADBFD4549088943A8A910555E9EA76457AF5133A8ABDED106D42349498FB239A30BA07CDE6F7DA4470CE57E7A5FA8B0B8350D77255AB7F5AE7F9045F0419F794BCA71CB444385C4ACA54B5CEC37A5E367BFC561ABD035749F987A99C1ED93B239AA26258007E98FC9674AB54405A590F6C9F2D257795211E23FF6B5867601F821FEF9DFFC41C47844856982FCFAD6AEA903191595899B98CF39535121618CFC7A7FBE7D84707062423103D62D0A24292266C41295482413",
            "0x36E31395FC624958C5661C07945E9D43A1F450572E2D095D5AB76E3E8CBB1AFC46B786FE4BD9F43F1000CCA0E3D0BAB74CA426EE23EBFE9E09052DD32DCC3FB28C8E1FB26D16A7984952B8D888DCB8A3D6520361416DD5A66EC895481293CE32A2563224438FACAB52C403E3CA44555D911CF7CE471AC094AFAAF5D07BEEADE73C7A5416B8E4BBDC5E5F6CD96F283EE01C6ACEB2B422BB03EB3A1B47B211BA915804885272B645DABEE2C1346B5D35BCAD11E513EA850FEAF3719CCC82D42FED91A70EBEF2C52653ED7CE72C42553131732A1D0B38A21DD10E2E07B9B4AE8C9222A1D7AEE22D66F640220919492F2D1B9818A9402A1A5537946A9331536DB7057B6683DB842BE79EF2A0C9E04943DF1A8FB9F5706193D4BA2781FE4D38D194EBE9BC858B26C2EF944ED0383ED4BE6B9CB0FE3239464172D1CD3D02A222F979687AB440E0EE018497B0030F0567D7DDF9320DDFF1E420D1DBE5832A6484867C0D2BD77183920EF54D4F5A07E585BFC3A8186712A01B62DECBFED5F6A2303B9167",
        ]
            .iter()
            .map(|s| MPInteger::from_hexa_string(s).unwrap())
            .collect();
        let r = MPInteger::from_hexa_string(
            "0x3524F1F180BAE1E4DCDFF8C12F03AC1776FE58679793F720A6034B10DB7EAC63564692122CAAEC32D5E01A14C0E81243D0281CBBAD43F8105E9D738CAA92397988836DC874EF61D58026C9E800BA547AE9BE89891CC8ACC3704434F41C07FC3A9CFA6E95D1CCD774C383E863764EB613294EA1DB4D54179A19D0A04DF835300D7D2FFC4917C537D97F629E509B698FB0F347BDB319FF1BB7BEE3407DEE4E7C9F4A218E30A93D1EFB5F6ABE5564D43BEBB72A49DB34DB7EA054F00CAA3C030C3BE341A001CCEBC4205766FA279A60F1903B1D89CFE8A9E869DDDB6240BC6CEBD77BF241501C4CEB8833CB219326FAB612A8962563D7FF17073B152E77E4EB7437E090B11C2C0FCBCB7B7674B259C963C194C2778F8FBD582C8CBA5EA81182F8BEF2D7AEAD85195DBD83553797410DB553C3FBEA0505E39AD726AC514B77A12560F31F8B5BE2FC82291365018FB85C43EE904E62D1712AE094A698CA97FA40BEA764D1994DE7604F6402B9A9EB21A09AA898DC0BBACCFCF5EF6F1C623AEAA4FB44"
        ).unwrap();
        let pks: Vec<MPInteger> = [
            "0x486DFFD322CAE9924A82215B26822BE9C5B36F88DCB8BC81309A9B6BB1D32FF4EB2AEDE88C5FF14B2C3409A965811DA5DB281F71F917D490133D058D34A0F3FA6D2363BEBB1730FE43BDAFEF9D3DD4469F5AF750D343B60A9264BE9A21C8354761B9D9946EC1240390AF3090BE0844341C1AD6F768DB8E4CC8B57FFCDA293B30FD4B6C7243EFE22F8863BB1417E2ECB9542326E40B7978FAA9B94C9820FA6B4280803EA2345F1BFE31AA466D6263BCE8071AE547486ECFCA868BFF80F070275B9EE66C501297700B159AC74DEF701738CB64AD05A18AA5E3770B1DB043A617F1E44EE7E25E066EA45FA0B1791D7D4C641BEA9EBA293A21F910275D16B2AEBE4FE77F80B8B1BBCED29A025ADFEE904DFEFC3EC7149BA3522DDAB9C2B3E6A8EB29CF03D5C98CF8B68C1CC9FECEC9896F59EC1797734939FD611AB73ADA9A96F96D9DAD8F3B4CFA215A7151DADD50A7826827983B2A40B5737AC462C0BFD1AD12D3C1E78930E275E2789912AAB84AEB2FB9D59D2D507AC87DAF3D690EDCA8EF884B",
            "0x5BFA48E2537F2DA739A454A35C516D1C3975190C39D35ADBBBA3264DE04E259828B84793941A67E681C6F3EBE6A1BDE681BB2C15E6578EC2346846614D76441C6A251AD080CAEBADF7213F81F4C5C113F43167C2248F40714F0071839A76FC83D854A22FEB1BDCED189023B171606B363BF0F9B42B69EC4C0BE4913309733243BEA7FA91F721463B98C0054B5545E8A20217EDF3F80055EE4F35BC18949745AD575A2659B0554945D21FCC6397AF969348B3689F0DB27D2E27AE8DB1F6E99A57F8F4B5A2AA2E02D59072D86E1DC98F20432730D8DCCB07F0B387BFDD40C83E8D050C804741BEA41C78CC17DC67F1B1A0E6913C2461E179064D55C12C984A8A01427A25747D540F4E394AEC4C19B904BE08DA4EAEAB6E2EC9365D32065E39F89047E42BBBF26647FA1AA6B6E49BC9E9CAB2DA568A36A4292E2E7DF34A11F05C6A7182A4B6325645AD076290CD236B0987360CF82FF187B724798DB895D0615D129ECD6658F8A21916888B236395F2184F5CD3AAF443706AD37A416AF0832367C4",
            "0x8BCB3B457E1E0E302BFB925296D78CCB4FCE1C3FF274E21D9BAB0E17197B228D0DE7110463F07FC80F08926F876ED5DD977C411E26ACE82A91AE349F0F174F600E792492FB1C10F5F5A5DACF9D17E89CB67DC46735146B0B018F8A99D6503D3CA085375379562DA7AFE32828B3AE6C39B1BCBA0E6FD3E35BF0FB05CA859FAD6A314EAF157BABF8781C33CC090F522DFEDE046FEABD4111265C5CFC8F9FEDD4D60DD194A3D2683D51F48004236845D1B29DAB781F3ED484A31A96DA239885953638E79FF2D5271C1FC0C16C908AE720B9746D07288DEDDF472F6910C0ED7159EC9AA7ABAA08F9A50CB4D951DC32ADE86A30094BE30DACF9D4628B95AE88E489CDC8F23A265EB5D6132F75C29C6F3FE186CCD7D968EBC3F2390A0DA155AB9FC6E617B68DDC21FF8AD8D004E39275621D94C9B176596D68582C35A9F20F79F527EF419177190B6D15BD002CABE10AD31CF096FD0440A4C6E8F67C49ABBC372572B4265B6B6D67F61DCFD633D33BD293E5A4ED3B5AAAF75123B54D8B3B9B521664EB",
        ]
            .iter()
            .map(|s| MPInteger::from_hexa_string(s).unwrap())
            .collect();
        let gamma = MPInteger::from_hexa_string(
            "0x5CBCC4FAE729945B1F8A35EAE73C37B364849345E8D367EBE9D98D3790FF4E5C2EA9D2209F542764C2E61CAC6FCA9919181F6F2B7A654B0BAB9030B65AC2549C1A9319829AB3E67B321D6E06EA9DB63093790673AD503FE37E1CEFDE28F471286D7EE67C4BF4E585FBE943E63BA7B7ED16A5B9475C4B07C1D067C199FDC500E9883638200198D4EF0B7C0EBA44AB45799E7D66B0122BFB95DD3D1D6E56D10E21DE5E128C089F73EF211E2ABBFA5160E696E9AC55953A55EB12A0C6AC094BF669C84C582D090C70AA3B9AC6E355D979C70EE68DDCA65AB4CDF9BCA6BBB5BEC1DC5231C9560C552F706F9281F6AACC5092D21EB829AFD0A4B055ED6B8F93142A8155404A3862CAEBCA5851263D7C2175EC4C818EFF1845ADA49CA11730EDC4B7A59347B75835F93DA92DFE2194C73DC00B96979EABD7FB8F0D7BC9E2CD6B39F96B8CC6F30C700D333CFB609B738DA8EADB25EBC0A3F7E2FE26AC10144D957A1E8F009110EE8D16C9847CE5386586F814AE3EB058F1B6AD43F62086F6ED040EA796"
        ).unwrap();
        let phis: Vec<MPInteger> = [
            "0x4C0E985A698E08768E9CB30ACB81E7D587FD7C705EED638992D6674ABEEB439B8294F732800FE6780A3D1A5409DB82CA8CCBEFA8AF129ADA9F2B22527A027F9BF194CBF927288E53B6A34D10A7E7D9D637120B297E126FC1FCC59B66DB6AC42B2AC90C5427D55F107D9A13D1E4250A216F51C742D430A87AED795F9B3E5828AF33DA981150A0DEDDD450704E838EFBB5F893D72FD8CB6B0C401FF354A096DCE226CA5EEAFD02093EE6E542D4406F042DA1500F102967C1D318D5E41E7A3245FF3D9D4638E8D6D1F7136E4B23CE18812EFBE0993B9F81C53FC9634E55D617D28740F717834EC927844580E6FD54277E6037B56C84995E0336B50385B77160D633796C18BA554695DD9DCBE2BD66C9D4D5CD2E8BB1363DBB8810F89012519913FDCA74ED1F7E3E1CABBF4F37368CC5EE6499C635224CFF7AB3B174BA68BA18995AF10C77F5C778BC88DEC6EAE6A9ADA07BE1BFBCAF36A2CAC41558B2C6D5BE82C6F1303D7664002570F1A33701F278AC78182C5D818E406122FB477F32400BC46E",
            "0x7ADEBAE9158EB09CA3981C2DDDC5A53B026CD5EBB5D543B08E183C8FE527B6793D7CE606676C0B68BD44396D2976BA84E5449F62746ADAEC94D4A11AB189FDA9406EA3B6D8BC9E34962B2DB1C76902B491007045560CEE79D9F1858AD28B89E160E062E057B6DF4478BBDC689CB840BFD7B02CC4373CB67E473E8F3795F2AE0783EB4AE7B0509A832CB188FED1DB681678BAD53CF4FDFC53A127694AC32289D043EB1CD23FE46123A61A7826CF9CF02A4F7190F79FF4E57CCD8339E16711F96488ED93634620DFF840E71549CB7E56FC02BAD0D151D3586E0A020918CE6CE3E0972DC1F91991C199D77B0596EC28432019637FE8F8C102621E48A1EDBCF87B9E05299E1604B220B5BD88AA595BD19CDBE7E0D205261A0EEDFA07B8F52F35F51846E42B963A8AA38B47EB5462B674D973D820E8533F5195939417260F26D3BF82E2B2E8EE80D6A3BF4D589DAF16CAF587414DDB2DCAEE1D887A55B0C75BA146B243A46D380AE0D1581B7A0D0A8CB080E26FEB1317961AF60621A6D0A62C777ED",
        ]
            .iter()
            .map(|s| MPInteger::from_hexa_string(s).unwrap())
            .collect();
        let c_res = Ciphertext::get_ciphertext(
            &EncryptionParameters::from((&p, &q, &g)),
            &ms,
            &r,
            &pks
        );
        assert!(c_res.is_ok());
        let c = c_res.unwrap();
        assert_eq!(c.gamma, gamma);
        assert_eq!(c.phis, phis)
    }

    #[test]
    fn test_get_cyphertext_product() {
        let p = MPInteger::from_hexa_string(
            "0xB7E151628AED2A6ABF7158809CF4F3C762E7160F38B4DA56A784D9045190CFEF324E7738926CFBE5F4BF8D8D8C31D763DA06C80ABB1185EB4F7C7B5757F5958490CFD47D7C19BB42158D9554F7B46BCED55C4D79FD5F24D6613C31C3839A2DDF8A9A276BCFBFA1C877C56284DAB79CD4C2B3293D20E9E5EAF02AC60ACC93ED874422A52ECB238FEEE5AB6ADD835FD1A0753D0A8F78E537D2B95BB79D8DCAEC642C1E9F23B829B5C2780BF38737DF8BB300D01334A0D0BD8645CBFA73A6160FFE393C48CBBBCA060F0FF8EC6D31BEB5CCEED7F2F0BB088017163BC60DF45A0ECB1BCD289B06CBBFEA21AD08E1847F3F7378D56CED94640D6EF0D3D37BE67008E186D1BF275B9B241DEB64749A47DFDFB96632C3EB061B6472BBF84C26144E49C2D04C324EF10DE513D3F5114B8B5D374D93CB8879C7D52FFD72BA0AAE7277DA7BA1B4AF1488D8E836AF14865E6C37AB6876FE690B571121382AF341AFE94F77BCF06C83B8FF5675F0979074AD9A787BC5B9BD4B0C5937D3EDE4C3A79396419CD7"
        ).unwrap();
        let q = MPInteger::from_hexa_string(
            "0x5BF0A8B1457695355FB8AC404E7A79E3B1738B079C5A6D2B53C26C8228C867F799273B9C49367DF2FA5FC6C6C618EBB1ED0364055D88C2F5A7BE3DABABFACAC24867EA3EBE0CDDA10AC6CAAA7BDA35E76AAE26BCFEAF926B309E18E1C1CD16EFC54D13B5E7DFD0E43BE2B1426D5BCE6A6159949E9074F2F5781563056649F6C3A21152976591C7F772D5B56EC1AFE8D03A9E8547BC729BE95CADDBCEC6E57632160F4F91DC14DAE13C05F9C39BEFC5D98068099A50685EC322E5FD39D30B07FF1C9E2465DDE5030787FC763698DF5AE6776BF9785D84400B8B1DE306FA2D07658DE6944D8365DFF510D68470C23F9FB9BC6AB676CA3206B77869E9BDF3380470C368DF93ADCD920EF5B23A4D23EFEFDCB31961F5830DB2395DFC26130A2724E1682619277886F289E9FA88A5C5AE9BA6C9E5C43CE3EA97FEB95D0557393BED3DD0DA578A446C741B578A432F361BD5B43B7F3485AB88909C1579A0D7F4A7BBDE783641DC7FAB3AF84BC83A56CD3C3DE2DCDEA5862C9BE9F6F261D3C9CB20CE6B"
        ).unwrap();
        let g = MPInteger::from(4u8);
        let gamma_a = MPInteger::from_hexa_string(
            "0x113834A47977101D4ECD962B8163E03B5285AF19A60A8008C234A01A8C716C8F42830B8772B70FC6F961C71AD2508D41D613DD8F402F3A532256B29EEC33E94BEBDAEF525ED8C67BE43D0B4D131A8E7DCA831C0652A9B00B26C7E8CAC1E7C120243538194286AEABCF434C6069E5B69B99AE25CF3CFC04E76F3291549B700B371C6771EC89498B5E94CAAFA84C3BD7B61F978B47A66C678BA0716F3D235DB061E35967AB7DC2A6A8F897AC58DCD1A21E9E22AD8838AFF98716CE45B0BD1BBDA2857944BD49A22ACF65F581E36844021C4F9410D0F4C4FEE0D8389C65FE2309B5EFD879913504062ACB778C530C3F51CE96D9159D972869B1083DFD552B1E9432B4067699946D68CCBE83E8B7CF52E3CF275DE579E8A065AB192BE04ACE6B94B41574967E37F081C678FD98076687BDBE841FB7AEFD5C67B875335AFF37FD6FDC5F862F7B8165761AEFD0C57E29D163DFD71E1335E17C9B8112B66D7FCC511E29B29D2E513FE32CB03C5F03286CF45EAD4D2153491415B86C5DADE0F95980323F"
        ).unwrap();
        let phis_a: Vec<MPInteger> = [
            "0x9624FEF18E71381727D2B3212BA5EC4B1A15F94061293CC6E7536E4D3B6A996BD4A00BCD8F6BA389CD77CFE1A4F8E1CCDDAF934BF6DD6CCD56ACAB248835A601490201D101B7CB038631A791C5BB9E8CC9B5C0A41ECDC41D8BF1BE154AA658AF70DB77F9E5284B0EE9639A7DF180E618C484BA7966961A2232CF13B755F01ABEFB24B85FD158D4BF7761B5BE9E5653820EC0694FFCC2BD31D08D4022D054DC67EA1656472835CD6CF73F88E3F3A245F414E5868368F5FF21FA88E4B9839D3E7F38B16780A2C60A21608AB5E2EC34D91EA74610B6A6DD1708E527AA536EE9003420C8514AA799F2876F0A70CE51DDB46986A22D191BE7C0471E5C96020BB9A9F2602B7A470EE0063922E59F86B7EB1C188A2A3DE4969B92E10D84D6A260AE57DD8FB4D8BB0FFADCC88F7B1038614D38E1A50048E1E47F7F2E097034568641321F1C1963E5AA62074A34731DDD38EFC93425F3F17941B594B053DF6C676A7ECBF0ABB1F95758997FE962F7F0445A45CD39793F043303328D1B5A9FB5B9C056412A",
            "0xC2706D74BE479E61F6968D9F1B189CA77802CC5AEE1F8CE2311465215BA779DB929D6FD4C040B846FF3DAD3A969207F20AA2BEDC73D9061C45FCBDDA74741803642563DD9F0E20084AF29270208123583A1D6B318EA70501B687535407DEA931B96713E4F7EE5DA9F99398E12F581F363E9252438DFEC0348C551E587731650B8A95D5EF8BE2238F0C091186F34A939E38F5FD062E7592AA325448846B65E4DC4E5A0490BC9E2594536D1FDF97DD88B71E1F5503E20089A91DB5BF82AEEDEF1F456BB20442BB8DBBF52FB6EC662349FD8E1D0652199CADB7D5BF69626678A2CD809FA2E4E74879DEB8C9B3BFC7EDCE1472F8108C9F8DC0C66CEFEA8CD11DF7CEF097B20EC384ACD6B00F4ABDBE5D3ABB01752112E20C56210D74068D94F05D81A333E75C90D3E662189DCF4BA9E9C5CA72E4474461AF70E6459EC8B7C46AB2657DBCE5824720938B76E2CEBC286B7EDF9F2251A7D72095ABD4955DBCB360FA38BA49FAF5CD63C34714130662B2E4ECA0C529C62AE6782369371AFAB082F7B97",
        ]
            .iter()
            .map(|s| MPInteger::from_hexa_string(s).unwrap())
            .collect();
        let gamma_b = MPInteger::from_hexa_string(
            "0xA4979976B83A9AFAF25593A04C40120E48750DE21B32A507C11491FD585B8E3EAEF09E441AD8116D2DD2B16018E0EDA94AF92CCDD032D9CC39DD77E2FFC3286BFCDC965AF48B901FA6E8BEAF7E22B77217A7CDA9A2E7DB1FC1304F952296EA44C2586A50080D67BCAD5D7571FC08A4FA50C7E2BFE279900F45B5BC946CCC6CCF2F77ADC5E4554EA53DED06AF5F642F4721D97689491BA6B4D782006739DF20F96B703E134F83542BCE418BC0FB40617EAC67341F82192B315CDA65CC6C2A2F35C20F1EE571DAFF4B2FE80FD2E57D476F54E265831B37A858709279984D2AC70E58DB35F2402B4FCDE4C0AAFFB2C2328BC1E5A1A7571B53568CBD28F25B891E4CAD42ACE1881FEEEBE751D30C23B02644730F2F5B6988A68CE5B4638139C9FB0B469665F3C6B97E07F4265B80B98B18D574AB21F52D92D08615EF6FFBCC276ED418771E0D60CB172C437E67CA6FC3AA22936C949D843F28136E53D7603DEA56B404345E514BA090694265579394F296B4C0BE9F1261D62EAD5AA2F4FAAC17DFCA"
        ).unwrap();
        let phis_b: Vec<MPInteger> = [
            "0xA48B675935B215B9197895FC76872F4B44AFF4B41CA4EDDABDF0C71CDEB171E03993FAACC38651F99EA4F2EE0B9BCE486832A0B609C288BD9CE4B3FD16C51614C3D9A0A868FE496E0E78F2F16232520BF23CBBB84FDC0435D1E258A0F70FAB016DC5291962FA2626BA82940EF983AF7298C47E021B2A1F2FDEB8E169A37AF3CE8CA7612C7F4979CE75ADE4622A039159E0990BA70AB48FA8B221125E48BA73595DA3A3C4A04068EB4BAFABD6FEDEFFC9C5E67AD326F132037F1894D5DD6CA42FF4E580BBE631806F73CA5D5E9D39AD0D2F36328B941D5870F74A06CCD0E5E55BEC71F00A991A16C1A268E879F9787218B26B1663283F3F73BCDAD19D2A74DDA6D30FE13C256279BDB3E3F4FC1AA2E9C52270F177785645A6B5369108FE45099309DF198A1983B2FD6C4652908B7F8F8854A95A90FB09D115F237D82E9C2B48CD3ACDBCC3224DC3621450BA5B4C6C6F945697EEB9656DF025168D5C083D9C150E9E8F139EB880DC04AC721990A5A2DB4E78ABCC4700A4FCFD392C26CDAEBCCF1D",
            "0x874B436C55F8B5BFED742BBA66A80CDC2DBC761B4FF0BA71AB4016345F64EC222BA59EBFA230DE1F0BA4F799142FA070E844DB1C2F070BE9D42908DEF757104893DC968BA359AA464C042FA3CE41147B103EDE84778169DA42FFACAA747A8C168B03FBF446F15E0FA2CFE1D362E5A2C61E001F0A6E3C8A769450511BEA4505BB899561CE17A1CAF83187F1941651F939C4713014F7B1FDF75EAE69E5DB92B5846B2BFEECA9BA35CF558D6F616F06E7AD3B1A50C173F27A846FBBA00C7CDA60B5DB61C634853ED92DB9D7FA5721FDF7273FE14E5C6FB59779C4D6BACF9AD452A428BC925CA1FA25D6A0A02E45BEAB1D1537BC15A26445C3784524EBF5B2E2E0BC5202E911D57C65BE6A36CB05270BB88326B424C28AB766CF16CF1D3C063AEE33ADD17D3D168C9F5FC6892BD992295EAF15F4A65D65BAA777060B6C447437DC833EB0867F36BE39C41B1A08731DC782A057EF2C00C07BC8C3A43B41A6C7AFBC30B130DEC96F4BD92E00263FF74FA74712C454CD49908815F56830A6BE39F34D0D",
        ]
            .iter()
            .map(|s| MPInteger::from_hexa_string(s).unwrap())
            .collect();
        let gamma_res = MPInteger::from_hexa_string(
            "0xABA7FE8A9B40A64A0CB19A7779E0FA2734AA736413E7A02B36330B4E8BB597EF79B6385B48CC63CB27565E7E611790D00715E822CCE8A955B29A2F7E9C7D5492045E011D00D42FEEEE436DBD706657C99B3D147C5D1CAD9F689BFAD6E4D75B5875639122BDC8A956BB7BBCD6933EA11D39C680072BD932FA0F30DBDCAB04AE8214DE6902CA9DE64F8E273A99C5950188990791F1FA8E3C23E83F8C35C656806FB04C2F6EBCBFFA08A13FF054FD468C05277B4160AFDA814FA6D2D46E5F6C738B6069E98EFCEF81E74B7956439663F9DB762651D0B447A26B95D0182703695A125C18BDC0FFB77E97118D56086407FAA8D2F2D0129A4C78F39F6C4BA887BA868A526DE81D2D5BA2C4749F8F6B727F4EAA693AF3B40E5374A4266C414AC2346B592CFB08F929ACE40D649592802EC59BB9A6139338939878430292F631BC004D990739414B19339554D3DE642713371AB9D25E941512E9BE9F6F43634AFB4DD2577E38B7B02AD476628A2FFBF83FA7A60A5785E2D0584DD09C11336F7F66CAB9CA"
        ).unwrap();
        let phis_res: Vec<MPInteger> = [
            "0x6C96BC44889C37B02D316F0E188C7F1E18D9B78621F5C60DE63A304C8261C65DBB4B6CE7CA187518AFB0DC82F6FBB1F2ED45436B6104633A4F229B2360660C96734A114600826E40D822353E2FCCF16955D305E2B1264D8C9AE0A78D5EE92C0BAB8E2858644C33B6BCD650DFC5A15B5A509F84FA41E74621BDD7A93F01D4B528C9B621CC3266E1D549BE3C99513ADE134BB59D49DDAD7A7CCA3603DE6D888683BE098ADA934FEC5225399138F4B87F1ABC1FFEF50008C66A4DECE1F6F46F18F3E663B58D0EED7986EFDDEE26F0CDE2C8A54E82946DEB89B50015374C11CE53535EC5DA08EC8A5FAECEB4AB7E8F67BF5337504F7C3CC6D46D8FCAA5A7A3D146ACAD664D49FE3F076CA00726602E70820936BA9759DDF1688FD74612F2DDE0E8FFBE772AD2D6923F3BE71B41B4F3812C846583515640220360AAC98BF30996B3E52741D0DBD4920D9492041B2CB8711FBC9C65DA2287F7586558EAFFB5B9966A95E24079A55338E0888794CBB9A8C7162E42CA11253861C1443528D5062B679727",
            "0x6E155E191366831D0DD4C9C13DEF812917A02307E8E72A27D77DBAC0308E28DF167FD8D1D240865D28EAEB3F9443DEFD6878BE1F4829E49D96D0631E6B3FC3ED1779CC78FF384D19CF3852B98DB9C912584E2C7534DF595BF57559061EF4A197FFF808848286C8953E8213F271943E2D781931451C666D43C3C9254208E04E83CE43DCFAD89E3AA02F8B5E9BC8292E0DB8D319F4056873ADB23C975F572BC6A2B537BECBD5958C36FC335068B6D061781720C7FF9AFE765DAB8FD175AC1456C466ECE14A7015FAE9B1CC596141CA8E00FE29322BCBD4E43C89CEAC1A0996EE7E7B6694782A957654202C9D47DC7B3E5808B83E362065BC68C480BA6B3A5ECE78CFB984A83DF3F40869E97F34DCC3EB4BD18E64229AA9CCE68F1CA260105074618E65071B3F79B4DBFC3DF69E6C0D25B25B860203B29E3C104657A17858D36EB3C94595E023AE7EAB5A281B1D0D81237F746A161C2A63922C9B05CB45986C360E5AFA994A349D17F71B201725D9702A7B81D12BD1F14E7D80EF6DA4BB9A291AD8",
        ]
            .iter()
            .map(|s| MPInteger::from_hexa_string(s).unwrap())
            .collect();
        let res = (Ciphertext { gamma: gamma_a, phis: phis_a }).get_ciphertext_product(
            &(Ciphertext { gamma: gamma_b, phis: phis_b }),
            &EncryptionParameters::from((&p, &q, &g))
        );
        assert_eq!(res.gamma, gamma_res);
        assert_eq!(res.phis, phis_res)
    }

    #[test]
    fn test_neutral_ciphertext() {
        let p = MPInteger::from_hexa_string(
            "0xB7E151628AED2A6ABF7158809CF4F3C762E7160F38B4DA56A784D9045190CFEF324E7738926CFBE5F4BF8D8D8C31D763DA06C80ABB1185EB4F7C7B5757F5958490CFD47D7C19BB42158D9554F7B46BCED55C4D79FD5F24D6613C31C3839A2DDF8A9A276BCFBFA1C877C56284DAB79CD4C2B3293D20E9E5EAF02AC60ACC93ED874422A52ECB238FEEE5AB6ADD835FD1A0753D0A8F78E537D2B95BB79D8DCAEC642C1E9F23B829B5C2780BF38737DF8BB300D01334A0D0BD8645CBFA73A6160FFE393C48CBBBCA060F0FF8EC6D31BEB5CCEED7F2F0BB088017163BC60DF45A0ECB1BCD289B06CBBFEA21AD08E1847F3F7378D56CED94640D6EF0D3D37BE67008E186D1BF275B9B241DEB64749A47DFDFB96632C3EB061B6472BBF84C26144E49C2D04C324EF10DE513D3F5114B8B5D374D93CB8879C7D52FFD72BA0AAE7277DA7BA1B4AF1488D8E836AF14865E6C37AB6876FE690B571121382AF341AFE94F77BCF06C83B8FF5675F0979074AD9A787BC5B9BD4B0C5937D3EDE4C3A79396419CD7"
        ).unwrap();
        let q = MPInteger::from_hexa_string(
            "0x5BF0A8B1457695355FB8AC404E7A79E3B1738B079C5A6D2B53C26C8228C867F799273B9C49367DF2FA5FC6C6C618EBB1ED0364055D88C2F5A7BE3DABABFACAC24867EA3EBE0CDDA10AC6CAAA7BDA35E76AAE26BCFEAF926B309E18E1C1CD16EFC54D13B5E7DFD0E43BE2B1426D5BCE6A6159949E9074F2F5781563056649F6C3A21152976591C7F772D5B56EC1AFE8D03A9E8547BC729BE95CADDBCEC6E57632160F4F91DC14DAE13C05F9C39BEFC5D98068099A50685EC322E5FD39D30B07FF1C9E2465DDE5030787FC763698DF5AE6776BF9785D84400B8B1DE306FA2D07658DE6944D8365DFF510D68470C23F9FB9BC6AB676CA3206B77869E9BDF3380470C368DF93ADCD920EF5B23A4D23EFEFDCB31961F5830DB2395DFC26130A2724E1682619277886F289E9FA88A5C5AE9BA6C9E5C43CE3EA97FEB95D0557393BED3DD0DA578A446C741B578A432F361BD5B43B7F3485AB88909C1579A0D7F4A7BBDE783641DC7FAB3AF84BC83A56CD3C3DE2DCDEA5862C9BE9F6F261D3C9CB20CE6B"
        ).unwrap();
        let g = MPInteger::from(4u8);
        let ep = EncryptionParameters::from((&p, &q, &g));
        let gamma = MPInteger::from_hexa_string(
            "0x113834A47977101D4ECD962B8163E03B5285AF19A60A8008C234A01A8C716C8F42830B8772B70FC6F961C71AD2508D41D613DD8F402F3A532256B29EEC33E94BEBDAEF525ED8C67BE43D0B4D131A8E7DCA831C0652A9B00B26C7E8CAC1E7C120243538194286AEABCF434C6069E5B69B99AE25CF3CFC04E76F3291549B700B371C6771EC89498B5E94CAAFA84C3BD7B61F978B47A66C678BA0716F3D235DB061E35967AB7DC2A6A8F897AC58DCD1A21E9E22AD8838AFF98716CE45B0BD1BBDA2857944BD49A22ACF65F581E36844021C4F9410D0F4C4FEE0D8389C65FE2309B5EFD879913504062ACB778C530C3F51CE96D9159D972869B1083DFD552B1E9432B4067699946D68CCBE83E8B7CF52E3CF275DE579E8A065AB192BE04ACE6B94B41574967E37F081C678FD98076687BDBE841FB7AEFD5C67B875335AFF37FD6FDC5F862F7B8165761AEFD0C57E29D163DFD71E1335E17C9B8112B66D7FCC511E29B29D2E513FE32CB03C5F03286CF45EAD4D2153491415B86C5DADE0F95980323F"
        ).unwrap();
        let phis: Vec<MPInteger> = [
            "0x9624FEF18E71381727D2B3212BA5EC4B1A15F94061293CC6E7536E4D3B6A996BD4A00BCD8F6BA389CD77CFE1A4F8E1CCDDAF934BF6DD6CCD56ACAB248835A601490201D101B7CB038631A791C5BB9E8CC9B5C0A41ECDC41D8BF1BE154AA658AF70DB77F9E5284B0EE9639A7DF180E618C484BA7966961A2232CF13B755F01ABEFB24B85FD158D4BF7761B5BE9E5653820EC0694FFCC2BD31D08D4022D054DC67EA1656472835CD6CF73F88E3F3A245F414E5868368F5FF21FA88E4B9839D3E7F38B16780A2C60A21608AB5E2EC34D91EA74610B6A6DD1708E527AA536EE9003420C8514AA799F2876F0A70CE51DDB46986A22D191BE7C0471E5C96020BB9A9F2602B7A470EE0063922E59F86B7EB1C188A2A3DE4969B92E10D84D6A260AE57DD8FB4D8BB0FFADCC88F7B1038614D38E1A50048E1E47F7F2E097034568641321F1C1963E5AA62074A34731DDD38EFC93425F3F17941B594B053DF6C676A7ECBF0ABB1F95758997FE962F7F0445A45CD39793F043303328D1B5A9FB5B9C056412A",
            "0xC2706D74BE479E61F6968D9F1B189CA77802CC5AEE1F8CE2311465215BA779DB929D6FD4C040B846FF3DAD3A969207F20AA2BEDC73D9061C45FCBDDA74741803642563DD9F0E20084AF29270208123583A1D6B318EA70501B687535407DEA931B96713E4F7EE5DA9F99398E12F581F363E9252438DFEC0348C551E587731650B8A95D5EF8BE2238F0C091186F34A939E38F5FD062E7592AA325448846B65E4DC4E5A0490BC9E2594536D1FDF97DD88B71E1F5503E20089A91DB5BF82AEEDEF1F456BB20442BB8DBBF52FB6EC662349FD8E1D0652199CADB7D5BF69626678A2CD809FA2E4E74879DEB8C9B3BFC7EDCE1472F8108C9F8DC0C66CEFEA8CD11DF7CEF097B20EC384ACD6B00F4ABDBE5D3ABB01752112E20C56210D74068D94F05D81A333E75C90D3E662189DCF4BA9E9C5CA72E4474461AF70E6459EC8B7C46AB2657DBCE5824720938B76E2CEBC286B7EDF9F2251A7D72095ABD4955DBCB360FA38BA49FAF5CD63C34714130662B2E4ECA0C529C62AE6782369371AFAB082F7B97",
        ]
            .iter()
            .map(|s| MPInteger::from_hexa_string(s).unwrap())
            .collect();
        let ciphertext = Ciphertext { gamma, phis };
        let one = Ciphertext::neutral_for_mod_multiply(ciphertext.l());
        let mult_a = ciphertext.get_ciphertext_product(&one, &ep);
        let mult_b = one.get_ciphertext_product(&ciphertext, &ep);
        assert_eq!(mult_a.gamma, ciphertext.gamma);
        assert_eq!(mult_a.phis, ciphertext.phis);
        assert_eq!(mult_b.gamma, ciphertext.gamma);
        assert_eq!(mult_b.phis, ciphertext.phis);
    }
}
